part of 'utils.dart';

extension StringX on String {
  /// Removes trailing whitespaces and carriage return characters.
  String normalizeWhitespaces() {
    return replaceFirst(RegExp(r'\s$'), '').replaceAll('\r', '');
  }

  /// Returns a string formatted using [DartFormatter]
  ///
  /// This is a workaround for generated code by the contributors,
  /// as the generated code in test has always length of 80 characters.
  String dartFormat({int lineLength = 100}) {
    return DartFormatter(pageWidth: lineLength).format(this).normalizeWhitespaces();
  }
}

typedef ContributorConstructor = AssistContributor Function(String path);
typedef OffsetProvider = int Function(CompilationUnit unit);

extension InOutFilesList on List<InOutFilesPair> {
  /// Computes and returns the assists generated by the
  /// passed contributor for the the given file.
  Future<AssistCollectorTest> computeAssists({
    required final String path,
    required final ContributorConstructor contributor,
    final OffsetProvider? offsetProvider,
  }) async {
    final AnalysisContextCollection analysis = AnalysisContextCollection(
      includedPaths: <String>[path],
      resourceProvider: PhysicalResourceProvider.INSTANCE,
    );

    final AssistContributor assistContributor = contributor(path);
    final AssistCollectorTest collector = AssistCollectorTest();

    final ResolvedUnitResult resolvedUnitResult = await analysis
        .contextFor(path)
        .currentSession
        .getResolvedUnit(path)
        .then((SomeResolvedUnitResult value) => value as ResolvedUnitResult);

    final CompilationUnit compilationUnit =
        (analysis.contextFor(path).currentSession.getParsedUnit(path) as ParsedUnitResult).unit;

    await assistContributor.computeAssists(
      DartAssistRequestTest(
        offset: offsetProvider?.call(compilationUnit) ?? compilationUnit.beginToken.offset,
        length: compilationUnit.length,
        resourceProvider: PhysicalResourceProvider.INSTANCE,
        result: resolvedUnitResult,
      ),
      collector,
    );

    return collector;
  }

  /// Runs contributor tests found in 'test_files' folder
  void runContributorTests({
    required final String contributorsPath,
    required final ContributorConstructor contributor,
    final OffsetProvider? offsetProvider,
  }) {
    for (final InOutFilesPair pair in this) {
      final String inPath = pair.input.path;
      final String outPath = pair.output.path;

      test('${path.basename(inPath)} -> ${path.basename(outPath)}', () async {
        final AssistCollectorTest collector = await computeAssists(
          path: inPath,
          contributor: contributor,
          offsetProvider: offsetProvider,
        );

        expect(collector.assists, hasLength(1));

        // Read the content of the 'out_.dart' file
        final String expected = io.File(outPath).readAsStringSync().normalizeWhitespaces();

        // Get the code generated from contributor's assists
        final String actual = collector.hasMultipleReplacements
            ? collector.assists.getGeneratedCode().dartFormat()
            : collector.firstReplacement.dartFormat();

        expect(
          expected,
          equals(actual),
        );
      });
    }
  }
}

extension on List<PrioritizedSourceChange> {
  String getGeneratedCode() {
    final List<String> replacements = <String>[];
    for (final PrioritizedSourceChange assist in this) {
      for (final SourceFileEdit edit in assist.change.edits) {
        for (final SourceEdit e in edit.edits
          // keep the order of the change based of the offset
          // same offset must keep the order of appearance
          ..sort((SourceEdit a, SourceEdit b) => a.offset - b.offset)) {
          replacements.add(e.replacement);
        }
      }
    }
    return replacements.join('\n\n');
  }
}
